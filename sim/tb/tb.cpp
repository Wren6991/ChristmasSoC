#include <iostream>
#include <fstream>
#include <cstdint>
#include <string>
#include <stdio.h>

#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>

// Device-under-test model generated by CXXRTL:
#include "dut.cpp"
#include <backends/cxxrtl/cxxrtl_vcd.h>

// -----------------------------------------------------------------------------

const float CLK_PERIOD = 1 / 40e6;
const float BAUD_PERIOD = 1 / 3e6;

class UARTRX {

	float baud_period;
	float time_accum;
	int rx_phase;
	uint8_t rx_data;
	bool rx_data_valid;

public:

	UARTRX(float _baud_period) {
		baud_period = _baud_period;
		time_accum = 0;
		rx_phase = 0;
		rx_data = 0;
		rx_data_valid = false;
	}

	void sample(bool rx_signal, float delta_t) {
		time_accum += delta_t;
		switch (rx_phase) {
		case 0:
			// Wait for start bit.
			time_accum = 0;
			if (!rx_signal)
				rx_phase = 1;
			break;
		case 1:
			// Check start bit, ignore frame if too narrow.
			if (time_accum >= baud_period * 0.5f) {
				time_accum -= baud_period * 0.5f;
				if (rx_signal)
					rx_phase = 0;
				else
					rx_phase = 2;
			}
			break;
		case 2: // fall-through
		case 3: // fall-through
		case 4: // fall-through
		case 5: // fall-through
		case 6: // fall-through
		case 7: // fall-through
		case 8: // fall-through
		case 9:
			// Sample data bit in middle of baud period.
			if (time_accum >= baud_period) {
				time_accum -= baud_period;
				rx_data = (rx_data >> 1) | ((uint8_t)rx_signal << 7);
				++rx_phase;
			}
			break;
		case 10:
			// Data is valid only if stop bit is correct
			if (time_accum >= baud_period * 0.5) {
				rx_phase = 0;
				rx_data_valid = rx_signal;
			}
			break;
		}
	}

	bool rx_valid() {
		return rx_data_valid;
	}

	char get_rx() {
		rx_data_valid = false;
		return (char)rx_data;;
	}
};

class SPIMem {

	enum phase_t {
		CMD,
		ADDR,
		DATA,
		ERR
	};
	phase_t phase;

	uint8_t cmd;
	uint32_t addr;
	int shift_ctr;
	bool sck_prev;
	bool miso;

	uint32_t base_addr;
	const uint8_t *img;
	size_t img_size;

	uint8_t get(uint32_t addr) const {
		addr -= base_addr;
		if (addr >= img_size)
			return 0xffu;
		else
			return img[addr];
	}

public:

	SPIMem(const uint8_t *img_, size_t img_size_, uint32_t base_addr_) {
		phase = CMD;
		cmd = 0;
		addr = 0;
		shift_ctr = 0;
		sck_prev = false;
		miso = false;
		base_addr = base_addr_;
		img = img_;
		img_size = img_size_;
	}

	bool step(bool cs_n, bool sck, bool mosi) {
		// Soft-reset of interface on deselect
		if (cs_n) {
			phase = CMD;
			cmd = 0;
			addr = 0;
			shift_ctr = 0;
			sck_prev = sck;
			miso = false;
			return miso;
		}

		switch (phase) {
		case CMD:
			miso = false;
			if (!(sck && !sck_prev))
				break;

			cmd = (cmd << 1) | mosi;
			if (++shift_ctr >= 8) {
				phase = ADDR;
				shift_ctr = 0;
				if (cmd != 0x03u)
					phase = ERR;
			}
			break;

		case ADDR:
			if (!(sck && !sck_prev))
				break;

			addr = (addr << 1) | mosi;
			if (++shift_ctr >= 24) {
				phase = DATA;
				shift_ctr = 0;
			}

		case DATA:
			if (!(!sck && sck_prev))
				break;

			miso = (get(addr) >> (7 - shift_ctr)) & 0x1u;
			if (++shift_ctr >= 8) {
				++addr;
				shift_ctr = 0;
			}
			break;
				
		case ERR:
			miso = false;
			break;

		}
		sck_prev = sck;
		return miso;
	}
};

// -----------------------------------------------------------------------------

const char *help_str =
"Usage: tb [--bin x.bin] [--vcd x.vcd] [--dump start end] [--cycles n] [--port n]\n"
"    --bin x.bin      : Flat binary file loaded to address 0x100000 in flash\n"
"    --vcd x.vcd      : Path to dump waveforms to\n"
"    --dump start end : Print out memory contents from start to end (exclusive)\n"
"                       after execution finishes. Can be passed multiple times.\n"
"    --cycles n       : Maximum number of cycles to run before exiting.\n"
"                       Default is 0 (no maximum).\n"
"    --port n         : Port number to listen for openocd remote bitbang. Sim\n"
"                       runs in lockstep with JTAG bitbang, not free-running.\n"
;

void exit_help(std::string errtext = "") {
	std::cerr << errtext << help_str;
	exit(-1);
}

static const int TCP_BUF_SIZE = 256;

int main(int argc, char **argv) {

	bool load_bin = false;
	std::string bin_path;
	bool dump_waves = false;
	std::string waves_path;
	std::vector<std::pair<uint32_t, uint32_t>> dump_ranges;
	int64_t max_cycles = 0;
	uint16_t port = 0;

	for (int i = 1; i < argc; ++i) {
		std::string s(argv[i]);
		if (s.rfind("--", 0) != 0) {
			std::cerr << "Unexpected positional argument " << s << "\n";
			exit_help("");
		}
		else if (s == "--bin") {
			if (argc - i < 2)
				exit_help("Option --bin requires an argument\n");
			load_bin = true;
			bin_path = argv[i + 1];
			i += 1;
		}
		else if (s == "--vcd") {
			if (argc - i < 2)
				exit_help("Option --vcd requires an argument\n");
			dump_waves = true;
			waves_path = argv[i + 1];
			i += 1;
		}
		else if (s == "--dump") {
			if (argc - i < 3)
				exit_help("Option --dump requires 2 arguments\n");
			dump_ranges.push_back(std::pair<uint32_t, uint32_t>(
				std::stoul(argv[i + 1], 0, 0),
				std::stoul(argv[i + 2], 0, 0)
			));;
			i += 2;
		}
		else if (s == "--cycles") {
			if (argc - i < 2)
				exit_help("Option --cycles requires an argument\n");
			max_cycles = std::stol(argv[i + 1], 0, 0);
			i += 1;
		}
		else if (s == "--port") {
			if (argc - i < 2)
				exit_help("Option --port requires an argument\n");
			port = std::stol(argv[i + 1], 0, 0);
			i += 1;
		}
		else {
			std::cerr << "Unrecognised argument " << s << "\n";
			exit_help("");
		}
	}
	if (!(load_bin || port != 0))
		exit_help("At least one of --bin or --port must be specified.\n");

	int server_fd, sock_fd;
	struct sockaddr_in sock_addr;
	int sock_opt = 1;
	socklen_t sock_addr_len = sizeof(sock_addr);
	char txbuf[TCP_BUF_SIZE], rxbuf[TCP_BUF_SIZE];
	int rx_ptr = 0, rx_remaining = 0, tx_ptr = 0;

	if (port != 0) {
		server_fd = socket(AF_INET, SOCK_STREAM, 0);
		if (server_fd == 0) {
			fprintf(stderr, "socket creation failed\n");
			exit(-1);
		}

		int setsockopt_rc = setsockopt(
			server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,
			&sock_opt, sizeof(sock_opt)
		);

		if (setsockopt_rc) {
			fprintf(stderr, "setsockopt failed\n");
			exit(-1);
		}

		sock_addr.sin_family = AF_INET;
		sock_addr.sin_addr.s_addr = INADDR_ANY;
		sock_addr.sin_port = htons(port);
		if (bind(server_fd, (struct sockaddr *)&sock_addr, sizeof(sock_addr)) < 0) {
			fprintf(stderr, "bind failed\n");
			exit(-1);
		}

		printf("Waiting for connection on port %u\n", port);
		if (listen(server_fd, 3) < 0) {
			fprintf(stderr, "listen failed\n");
			exit(-1);
		}
		sock_fd = accept(server_fd, (struct sockaddr *)&sock_addr, &sock_addr_len);
		if (sock_fd < 0) {
			fprintf(stderr, "accept failed\n");
			exit(-1);
		}
		printf("Connected\n");
	}

	size_t binsize = 0;
	uint8_t *binimg = NULL;

	if (load_bin) {
		std::ifstream fd(bin_path, std::ios::binary | std::ios::ate);
		if (!fd){
			std::cerr << "Failed to open \"" << bin_path << "\"\n";
			return -1;
		}
		binsize = fd.tellg();
		fd.seekg(0, std::ios::beg);
		binimg = new uint8_t[binsize];
		fd.read((char*)binimg, binsize);
	}

	SPIMem spi0(binimg, binsize, 0x100000u);

	UARTRX uart0(BAUD_PERIOD);

	cxxrtl_design::p_tb top;

	std::ofstream waves_fd;
	cxxrtl::vcd_writer vcd;
	if (dump_waves) {
		waves_fd.open(waves_path);
		cxxrtl::debug_items all_debug_items;
		top.debug_info(all_debug_items);
		vcd.timescale(1, "us");
		vcd.add(all_debug_items);
	}

	// Reset + initial clock pulse

	top.step();
	top.p_clk__sys.set<bool>(true);
	top.p_tck.set<bool>(true);
	top.step();
	top.p_clk__sys.set<bool>(false);
	top.p_tck.set<bool>(false);
	top.p_trst__n.set<bool>(true);
	top.p_rst__n__por.set<bool>(true);
	top.step();
	top.step(); // workaround for github.com/YosysHQ/yosys/issues/2780

	for (int64_t cycle = 0; cycle < max_cycles || max_cycles == 0; ++cycle) {
		top.p_clk__sys.set<bool>(false);
		top.step();
		top.step(); // workaround for github.com/YosysHQ/yosys/issues/2780
		if (dump_waves)
			vcd.sample(cycle * 2);
		top.p_clk__sys.set<bool>(true);
		top.step();
		top.step();

		// If --port is specified, we run the simulator in lockstep with the
		// remote bitbang commands, to get more consistent simulation traces.
		// This slows down simulation quite a bit compared with normal
		// free-running.
		//
		// Most bitbang commands complete in one cycle (e.g. TCK/TMS/TDI
		// writes) but reads take 0 cycles, step=false.
		bool got_exit_cmd = false;
		bool step = false;
		if (port != 0) {
			while (!step) {
				if (rx_remaining > 0) {
					char c = rxbuf[rx_ptr++];
					--rx_remaining;

					if (c == 'r' || c == 's') {
						top.p_trst__n.set<bool>(true);
						step = true;
					}
					else if (c == 't' || c == 'u') {
						top.p_trst__n.set<bool>(false);
					}
					else if (c >= '0' && c <= '7') {
						int mask = c - '0';
						top.p_tck.set<bool>(mask & 0x4);
						top.p_tms.set<bool>(mask & 0x2);
						top.p_tdi.set<bool>(mask & 0x1);
						step = true;
					}
					else if (c == 'R') {
						txbuf[tx_ptr++] = top.p_tdo.get<bool>() ? '1' : '0';
						if (tx_ptr >= TCP_BUF_SIZE || rx_remaining == 0) {
							send(sock_fd, txbuf, tx_ptr, 0);
							tx_ptr = 0;
						}
					}
					else if (c == 'Q') {
						printf("OpenOCD sent quit command\n");
						got_exit_cmd = true;
						step = true;
					}
				}
				else {
					// Potentially the last command was not a read command, but
					// OpenOCD is still waiting for a last response from its
					// last command packet before it sends us any more, so now is
					// the time to flush TX.
					if (tx_ptr > 0) {
						send(sock_fd, txbuf, tx_ptr, 0);
						tx_ptr = 0;
					}	
					rx_ptr = 0;
					rx_remaining = read(sock_fd, &rxbuf, TCP_BUF_SIZE);
				}
			}
		}

		if (dump_waves) {
			// The extra step() is just here to get the bus responses to line up nicely
			// in the VCD (hopefully is a quick update)
			top.step();
			vcd.sample(cycle * 2 + 1);
			waves_fd << vcd.buffer;
			vcd.buffer.clear();
		}

		uart0.sample(top.p_uart__tx.get<bool>(), CLK_PERIOD);
		if (uart0.rx_valid()) {
			putchar(uart0.get_rx());
		}

		top.p_spi0__sdi.set<bool>(spi0.step(
			top.p_spi0__cs__n.get<bool>(),
			top.p_spi0__sclk.get<bool>(),
			top.p_spi0__sdo.get<bool>()
		));

		// if (memio.exit_req) {
		// 	printf("CPU requested halt. Exit code %d\n", memio.exit_code);
		// 	printf("Ran for %ld cycles\n", cycle + 1);
		// 	break;
		// }
		if (cycle + 1 == max_cycles)
			printf("Max cycles reached\n");
		if (got_exit_cmd)
			break;
	}

	close(sock_fd);

	// for (auto r : dump_ranges) {
	// 	printf("Dumping memory from %08x to %08x:\n", r.first, r.second);
	// 	for (int i = 0; i < r.second - r.first; ++i)
	// 		printf("%02x%c", memio.mem[r.first + i], i % 16 == 15 ? '\n' : ' ');
	// 	printf("\n");
	// }

	return 0;
}
